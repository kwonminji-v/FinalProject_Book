안녕하세요 이번 저희 프로젝트에서 게시판 구현을 담당하였고, 발표를 진행하도록 하겠습니다.

-----API 엔드포인트 & ERD 설명------



--- 주요 구현 기능 설명 (슬라이드 별 분류) ---

1. 게시판 출력
담당한 부분의 주요 구현 기능을 말씀드리면, 우선 가장 먼저 게시글의 데이터를 테이블 형식으로 확인할 수 있습니다. 현재 작성된 게시글이 인덱스로 정렬되어 10개씩 페이징 되어 나타나고 있고 카테고리 제목 내용 작성자 조회수 작성일자등이 포함되어 있습니다. 그리고 왼쪽 상단에는 카테고리 별로 분류가능한 토글키가 있고, 오른쪽엔 input창에 키워드를 입력하여 해당 키워드가 제목에 포함되어 있다면 해당 게시글 데이터만 출력되도록 나타나있습니다. 

2. 작성 form
하단의 게시글 작성하기 버튼을 클릭하여, 게시글을 작성하는 form으로 이동이 가능합니다. 작성 form으로 이동하면 카테고리를 선택하고 제목과 내용을 입력하여 글을 작성할 수 있습니다. 글 내용을 입력하는 곳은 라이브러리를 사용하여 작성되는 글에 속성을 적용할 수 있도록 하였습니다. 그리고 하단에 작성자는 로그인 한 user의 닉네임이 나타나고 게시글 작성을 통해 DB에 저장 시 함께 저장됩니다.

3.게시글 작성 버튼의 경우 앞서 말씀드렸듯이 로그인한 user의 닉네임을 필드값으로 작성된 게시글과 함께 db에 저장되기 때문에 로그인 하지 않은 user는 권한을 갖고 있지 않기때문에 권한 확인을 위한 alret창이 먼저 출력 되어 로그인 후 게시글 작성 기능을 이용할 수 있도록 필터링이 되어있습니다.

4. 다음으로는 작성된 게시글을 클릭하여 상세게시글을 확인 할 수 있는 기능입니다. 게시글 목록에서 제목 또는 내용을 클릭하면 해당 상세 게시글로 이동되고,작성한 게시글의 상세 내용을 확인할 수 있습니다. 

5. 상세 게시글은 해당 글을 작성한 user 본인에게만 해당 게시글을 수정 or 삭제할 수 있는 버튼이 활성화 되도록 하였습니다. 해당 게시글을 작성한 당사자가 아니면 수정 삭제 기능을 하는 버튼이 활성화 되지 않음을 확인할 수 있습니다. 그리고 해당 게시글에 댓글을 작성하는 기능도 함께 만들어지며 댓글 작성도 가능합니다.

6. 본인이 작성한 게시글을 수정작업을 진행하면 우선 각 항목에는 기존에 작성된 사항들이 그대로 유지된 채 수정할 수 있으며, 수정 완료 후 게시글 목록에서 이전 데이터가 수정됨을 확인할 수 있습니다.

7. 게시글 삭제또한 상세게시글 에서 삭제버튼을  통해 실행하게 되면 삭제를 묻는 경고창이 뜨고, 확인을 누르면 게시글 목록으로 삭제요청한 게시글이 삭제되었음을 확인할 수 있습니다.

8.앞서 언급된 댓글의 경우 게시글 CRUD와 유사하게 진행됩니다. 게시글 목록에서 상세게시글을 클릭한 후 하단의 댓글 작성칸에 댓글을 입력후 저장하게 되면 댓글 목록이 생성됩니다. 댓글목록에는 댓글 내용, 작성자 , 작성일자가 보여지고, 댓글 역시 마찬가지로 댓글을 작성한 user 본인에게만 수정 / 삭제 버튼이 활성화됩니다. 옆의 이미지는 다른 user로 로그인 한 후 해당 댓글이 작성된 부분을 확인해보면 본인의 댓글에만 수정 / 삭제 버튼이 보여짐을 확인할 수 있습니다.

9.댓글 수정의 경우 수정 버튼을 누르면 해당 글에서 기존 댓글이 유지된 채 input창으로 변경되고 수정 후 저장하면 바로 댓글 목록에 업데이트가 진행 됩니다.

10. 지금까지는 주요 기능들을 말씀드렸고,  해당 기능들을 구현한 코드에 대해서 말씀드리겠습니다. 


----------------- 코드 리뷰 발표 ---------------------
1. 엔드포인트 설명 : 게시판 구현 시 사용된 API 엔드포인트입니다 해당 엔드포인트들은 통해 클라이언트에서 서버로 요청을 보내거나 DB에서 데이터를 가져오는 데에 사용됩니다.



















--------------- BOARD ENTITY -------------------

BoardEntity에서 필드값으로 선언된 사항 중 매핑 관계가 설정된 부분을 설명드리면, MemberEntity와는 하나의 게시글은 한명의 회원에게만 속하기 때문에 @ManyToOne 연관관계 매핑으로 설정하였고, 조인 컬럼으로 member_id를 외래키로 설정해주었습니다.

마찬가지로 댓글인 ReplyEntity와도 연관관계 매핑이 필요한데, 하나의 게시글에 여러개의 댓글이 작성될 수 있어 OneToMany로 일대 다 관계로 매핑하고, 이 때 mappedBy 속성의 값을 boardEntity로 설정하여 boardEntity 필드를 가진 ReplyEntity 클래스를 연관관계의 주인으로 설정합니다.

해당 클래스의 생성자로 엔티티들을 초기화하는데 사용하고, 내부 필드변수들을 매개변수로 받아 엔티티를 생성하는 생성자를 정의해두었습니다.

-------------- BoardDTO ---------------------------------
BoardDTO 해당 DTO는 엔티티의 필드를 갖고 있고, 엔티티에서 데이터를 추출하거나 엔티티로 데이터를 변환하는 데 사용됩니다. Entity를 DTO로 변환하는 메서드를 생성하여 Entity에서 DTO로 필드값을 복사하여 DTO를 생성하는데 사용하고, 정의해 둔 생성자를 이용해 Entity의 필드 값을 DTO필드에 복사하여 Entity를 DTO로 변환할때 사용합니다.

-----------------------------------------------

본격적으로 기능을 설명드리면 가장 기본적으로 필요한 기능인 CRUD를 말씀드리도록 하겠습니다.

-------- 게시글 작성 CREATE ---------

게시글 생성 코드 설명 : 먼저 create - 게시글 작성에 대해서 말씀드리겠습니다. 작성된 api 경로로 POST 요청을 보내는 createBoard메서드를 작성하였습니다. 메서드의 파라미터로는 HTTP 요청 본문에서 꺼내 BoardDTO객체로 받고 ResponseEntity를 사용하면 HTTP 응답의 상태 코드를 작성할 수 있습니다.

이 후 BoardEntity 객체를 생성하여 게시글의 실제 데이터를 담아 boardService를 통해 DB에 저장한 후 게시글 작성이 성공했을 경우 HTTP 상태코드를 담아 응답 본문으로 ResposeEntity 객체를 반환합니다. 

프론트 엔드에서는 axios를 통해 request_data에 title, category, content, writer 등의 필드를 객체형태로 생성합니다. try , catch 블럭을 사용하여 예외 처리를 통해 올바르게 실행되면 페이지를 새로고침하지 않아도 navigate를 통해 게시글 목록으로 돌아갈 수 있는 react 훅을 사용합니다. 만약 에러가 발생한다면 catch 블럭에서 resetInput 함수를 호출하여 입력 필드를 초기화합니다.


-------- 게시글 목록 조회 READ ---------

다음으로는 READ로 작성된 게시글을 조회하는 기능을 말씀드리겠습니다. 작성된 게시글 데이터들을 조회만하면 되기 때문에, Get요청을 사용하였습니다. board_list 메서드를 생성하고 메서드의 파라미터로 paging할 때 사용될 페이지 번호인(page), 페이지 당 보여질 게시글의 수(size)와 카테고리 , 키워드를 받습니다. Pageaber 객체를 생성하여 페이지 및 정렬정보를 설정하고, id 필드를 기준으로 내림차순으로 정렬합니다.

Page객체안에 BoardEntity타입으로 boardPage에 조회된 게시글 목록을 담고 조건에 따라 조건에 해당 되면 필터링 된 데이터를 불러오고, 없으면 전체 목록을 가져오도록 합니다.
↓ Page<BoardDTO> boardDTOPage = boardPage.map(BoardDTO::new);: BoardEntity
이 후 BoardDTO로 변환하는 작업을 수행한 후 조회가 잘 된다면 HTTP 상태 코드와 게시글 목록을 담은 boardDTOPage를 응답 본문으로 갖는 ResponseEntity 객체를 반환합니다

프론트 엔드에서는 해당 기능을 할 api에 필요한 url을 생성한 후 currentPage와 size, 정렬 기준을 작성합니다. 카테고리가 "all"이 아닌 경우에는 카테고리를 URL에 추가합니다. 즉, 특정 카테고리의 게시글을 필터링하기 위해 URL에 카테고리 파라미터를 추가합니다.
검색어가 입력된 경우에는 검색어를 URL에 추가합니다. 이렇게 하면 검색 결과를 가져올 수 있습니다.

const response = await axios.get(url);: Axios 라이브러리를 사용하여 서버로 HTTP GET 요청을 보냅니다. 앞서 구성한 URL로 요청을 보내고, 서버에서 반환한 데이터를 response 변수에 저장합니다. 


데이터 가져오기 과정에서 예외가 발생한 경우 콘솔에 오류메세지를 출력합니다.

---- 카테고리 조회 ----

게시글 목록에 포함된 카테고리 조회 기능에 대해 설명드리면, Repository와 Service에 category와 pagable객체를 매개변수로 받는 메서드를 이용하여 필터링된 특정 카테고리의 게시글 데이터들을 불러 올 수 있습니다. 앞서 게시글 목록 조회시 설명드렸던 axios를 이용하였고, select내의 옵션 값이 변경될 때마다 onChange 함수를 이용하여 category가 변경됨에 따라 데이터가 업데이트되어 출력될 수 있도록 구현하였습니다.

----검색어 조회 ----

검색 데이터도 마찬가지로 별도의 메서드를 작성하여,  제목에 해당 검색어가 포함된 데이터들을 searchResult라는 변수에 담아 3항 연산자와 map을 이용하여 필터링 된 데이터들이 출력될 수 있도록 구현하였습니다. 
검색어가 입력된 경우(if (searchText !== "")) 검색 결과를 setSearchResults로 업데이트하고, 
전체 페이지 수를 setTotalPages로 설정합니다.
검색어가 입력되지 않은 경우에는 전체 게시글 데이터를 setData로 업데이트하고, 전체 페이지 수를 setTotalPages로 설정합니다.


---------상세 게시글 불러오기 -------------

상세 게시글 불러오기 api는 GetMapping된 board_detail메서드를 사용하여 게시글의 상세정보를 가져올 수 있습니다. boardID 부분은 PathVariable을 사용하여 boardId를 파라미터로 매핑하여 경로변수를 지정해주었습니다. 클라이언트가 실제 게시글의 ID를 경로에 포함하여 요청하게 됩니다.boardService의 findOne 메서드를 이용해 게시글 id에 해당하는 게시글 정보를 조회하고,해당 게시글을 보기위해 클릭 하였을 시 조회수도 증가할 수 있도록 구현하기 위해 increaseView를 호출하였습니다.

조회된 게시글 정보를 BoardDTO로 변환하고 이를 WrapperClass로 래핑하여 반환하도록 하였습니다.


---------- 게시글 수정하기 --------

게시글 수정하기의 경우 데이터를 DB에 새로 저장해야하기 때문에 Put 요청을 사용하였습니다. update_board 메서드를 통해  HTTP 요청 본문에서 꺼내온 데이터를 boardDTO를 전달받아 결과를 Responsebody객체로 반환합니다. HTTP 상태코드를 Header에 담아 수정을 성공적으로 완료되었는지를 나타낼 수 있습니다. Service에 update메서드를 이용하여 변경될 수 있는 게시글의 id, title, category를 전달합니다. 이후 예외가 발생했을 때의 예외처리를 진행하고, 마지막으로는 해당 메서드가 성공 또는 실패한 경우의 응답을 반환합니다.


프론트엔드에서는 resetInput 메서드를 수정사항의 에러가 발생했을 때, 초깃값을 가지고 있을 수 있도록 정의하였고, 수정이 완료되었을 시엔 수정완료 alert창이 출력된 후 navigate를 통해 다시 해당 게시글의 상세보기 페이지로 이동하게됩니다.

--------- 게시글 삭제하기 ----------

Delete 역시 Update api와 유사한 방법으로 구현하였고, boardService에서 해당 게시글의 id를 찾아, delete 메서드를 이용하여 해당 데이터를 삭제할 수 있도록 구현하였습니다. 

front에선 request_data에 현재 삭제할 게시글의 id를 이용하여 삭제할 게시글을 식별하고,  axios를 사용하여 서버로 HTTP delete 요청을 보냅니다. 요청이 성공되면 화면을 업데이트하고 알림을 표시합니다.

-----조회수 증가 -----

게시글 조회수를 증가시키는 기능 구현을 간략하게 설명드리면 Repository를 사용하여 해당 게시글 ID에 해당하는 게시글을 조회하고 이를 Optional로 반환합니다. 조건문을 사용하여 isPresent메서드를 사용하여 게시글이 존재하는지 확인한 후 존재한다면 currentViewCount변수를 이용해 Entity의 view를 담은 후 해당 view의 숫자를 +1을 더합니다. 이 후 해당 게시글을 DTO로 변환하여 반환합니다.

--------------- ReplyEntity ------------------

ReplyEntity도 마찬가지로 연관관계 매핑이 된 부분만 말씀드리면, boardEntity와 memberEntity와 ManyToOne 매핑으로 설정하였습니다. 하나의 게시글의 여러개의 댓글이 작성 가능하고, 한명의 회원이 여러개의 댓글 작성이 가능하기때문에 해당 매핑으로 설정하였습니다.


------ ReplyDTO -------

이와 같이 DTO 클래스를 설정하게되면 클라이언트와 서버간의 데이터 전달이 단순해지고 데이터를 다룰 때 필요한 필드를 선택적으로 사용하고 효과적으로 관리하기가 용이해지는 장점이 있습니다.

RequestDTO는 클라이언트에서 서버로 데이터를 전송할 때 사용하고, ResponseDTO는 서버에서 클라이언트로 데이터를 반환할 때 사용하고자 생성하였습니다. Request 클래스에는 DTO를 Entity로 변환 하는 메서드를 , ResponseDTO에는 Entity를 DTO로 변환하는 메서드를 생성하였습니다.

특히 댓글의 경우 게시글과 댓글이 서로 참조하게 되는데, 이때 무한 참조가 발생할 수 있기 때문에 Request와 Response를 분리하여 사용하도록 하였습니다. 


-------댓글 작성 백엔드 (CREATE)-----------

댓글도 마찬가지로, CRUD 순서로 말씀드리겠습니다. 먼저 댓글작성의 경우 게시글 상세보기를 통해 해당 게시글 창이 보여지면, 하단에 댓글을 작성할 수 있는 창이 보여집니다.

백엔드 코드를 살펴보면 Service단계에서 구현된 코드에 대해서 먼저 설명드리면, 게시글에 대한 댓글이 생성되기 때문에 먼저 게시글과 유저 정보가 필요합니다.  
여기서 ReplyResponseDTO 형식으로 반환하는 이유는 앞서 설명드렸듯, 게시글 엔티티에 댓글 엔티티가 포함되고 댓글 엔티티에 다시 게시글 엔티티가 포함되며 서로를 계속 참조하게 되어 무한 참조가 발생하는데 이를 막기위해 DTO 패턴을 사용하여 엔티티와 별개로 데이터 전송 객체를 생성하고 반환하기위해 설정하였습니다.

boardRepository와 memberRepository에서 해당 게시글의 id로 BoardEntity를 그리고 user의 닉네임을 이용해 memberEntity를 조회합니다.
이후 댓글 작성에 필요한 정보를 setBoardEntity를 통해 댓글이 어떤 게시글에 속하는지와 setMemberEntity를 이용해 댓글을 작성한 사용자 정보를 RequestDTO로 형식으로 서버에 전달합니다.

그리고 댓글 Entity를 생성한 후 , 댓글 Entity에 memberEntity를 저장하고, save를 통해 댓글 Entity를 DB에 저장합니다.저장된 댓글 Entity를 기반으로 ResponseDTO를 사용하여 댓글 작성 결과를 클라이언트로 작성 결과를 반환하고, setNickname으로 댓글 작성자의 별명을 설정합니다. 마지막에 return 된 responseDTO에는 저장된 댓글의 정보와 작성자의 nickname이 포함되어 있습니다.


이를 컨트롤러 전달하여 해당 api 경로에 service에 만든 replyCreate메서드를 사용하여, ResponseEntity에 HTTP 상태 커드와 해당 dto를 담아서 실행되도록 합니다. 


----- 댓글 작성 프론트엔드 ------

재원님이 미리 구현해주신 getUserNumber()를 통해 현재 로그인된 사용자의 정보를 가져온 후 , 사용자 정보가 있다면 try문이 실행, 없다면 로그인을 우선 진행하도록 구현하였습니다.

axios로 POST 요청 url을 보내며, 이때 경로의 id 값은 현재 게시글의 고유 ID를 나타냅니다. 요청 파라미터로는 댓글의 내용과 사용자의 닉네임을 전달하고, 응답 데이터에서 새로 작성된 댓글 정보를 가지고와 newReply 변수에 저장합니다. 이후 setReplies 함수를 사용하여 기존의 댓글 목록에 새로 작성된 댓글을 추가하고 setReply 함수를 사용하여 댓글 입력란을 초기화 합니다. 


------ 댓글 목록 조회 -------

작성된 댓글을 불러오는 Read 기능을 말씀드리면, 먼저 Service에 전체 댓글목록을 댓글 Repository에서 불러올 수 있는 메서드를 만든 후 이 후 컨트롤러에서 GetMapping으로 요청을 처리하여, ResponseEntity타입으로 reply_list라는 메서드를 통해 service에 만들어진 메서드를 사용하여 해당 게시글에 대한 댓글 목록을 조회합니다. 

가져온 댓글 목록의 ReplyEntity를 ResponseDTO로 변환하여 responseDTOLIST에 담습니다.

댓글을 작성할 때의 닉네임이 null 값이 아니라면 responseDTO에 해당 현재 댓글을 작성할 시의 nickname을 담아주고 response객체들을 list로 수집한 후, ResponseEntity로 래핑하여 Http 상태코드와 댓글 목록이 포함된 리스트를 응답으로 전송합니다.


-- 프론트엔드 --

댓글을 작성하면 바로 상단에 댓글 목록이 생성되는데, getReplies 함수를 작성하여, front에서 axios를이용해서 게시글의 id값을 받고, replyList에 댓글의 데이터를 담은 후 댓글 목록변수인 Replise의 상태 변수를 업데이트 합니다. 이 후 id값 즉 게시글의 번호가 변경될 때마다 해당 함수가 렌더링 되도록 설정합니다.

출력되는 곳을 보면 map을 이용하여 replies 안에 들어있는, 댓글의 내용 , 작성자, 작성일이 출력될 수 있도록 작성하였습니다.

-------------댓글 목록 수정하기-------------

마찬가지로 서비스 , 컨트롤러를 설명드리면 service에는 댓글을 수정하고 수정된 댓글 정보를 ReplyDTO.ReplyResponseDTO 형식으로 반환하는 updateReply메서드를 이용해 게시글의 id와 변경된 댓글의 내용을 매개변수로 전달해 repository의 findById 메서드를 이용하여 replyEntity에 담은 후, 수정한 댓글의 데이터를 저장한 후 repository에 담길 수 있도록 작성합니다.

컨트롤러에선 PUT요청으로 경로변수로 댓글의 id를 이용하여 마찬가지로 RequestBody어노테이션을 이용하여 클라이언트로부터 수신한 요청 본문에 있는 데이터를 dto객체로 매핑합니다.
replyService를 호출하여 댓글을 수정하고 수정된 댓글 정보를 ReplyDTO.ReplyResponseDTO 형식으로 받아온 후, ResponseEntity로 래핑하여 클라이언트에 반환할때 상태코드와 수정된 댓글 정보인 responseDTO를 응답 본문으로 전송합니다.


-- 프론트엔드 --
updateReply 함수는 댓글을 수정하고 수정 결과를 백엔드로 전송하고, 수정된 댓글 정보를 화면에 업데이트 하는 역할을 합니다. replyId를 매개변수로 받아와 수정하고자 하는 댓글의 id를 setEditReplyId를 이용해 상태변수에 저장한 후 , 댓글 수정모드로 변경하기 위해 false의 초깃갓ㅂ을 가지고 있는 isEditing 상태변수를 true의 값으로 변경합니다.

수정하려는 댓글의 내용을 replies 배열에서 가져와 setUpdateReply(replyToEdit.reply)를 통해 상태변수 updateReply에 설정합니다.

이 후 axios를 이용해 해당 api 경로로 put 요청을 보내어 수정된 댓글을 백엔드에 전송합니다. 이 때, 요청 본문에는 수정된 댓글의 내용이 담겨져 있습니다. 
수정된 댓글 정보를 받아와서 setReplies((prevReplies) => prevReplies.map(...))를 통해 replies 배열에서 해당 댓글을 찾아 업데이트합니다.
마지막으로, 수정 모드를 종료하기 위해 setIsEditing(false)를 호출하여 isEditing 상태 변수를 false로 설정하고, setEditReplyId(null)을 호출하여 editReplyId 상태 변수를 초기화합니다.


---------- 글 삭제 기능----------------
먼저 reppository에 DELETE 쿼리문을 이용하여 파라미터로 댓글의 고유 id를 가져올 수 있는 메서드를 만든 후 서비스에 해당 id를 전달한 후 컨트롤러에서 deleteReply를 통해 경로변수로 댓글을 id를 받아 db에서 삭제하기를 원한댓글의 데이터를 지우기 위해 delete 매핑을 하였습니다.

try - catch문을 이용하여 삭제 성공 실패 시 http 상태코드를 ResponseEntity담아 반환하도록 작성하였습니다.
이 때, 조금 어려웠던 부분은 ReplyRepository도 JPARepository를 상속받았기 때문에 delete 기능을 기본적으로 가지고 있는데 해당 delete를 사용했을 시 쿼리문 생성도 안되고, db에서 삭제가 되지않아 보시는 것과 같이 따로 쿼리문을 이용하여 메서드를 만들어서 진행하였습니다.


--프론트--
프론트의 경우에는 삭제하기 버튼을 누르면 confirm을 통해 삭제 의사를 먼저 물은 후 axios로 delete 요청을 해당 api 경로로 보내 삭제 기능 수행 후 댓글 목록을 업데하이트 할수 있도록 작성하였습니다.

이상 게시판 기능구현에 대한 발표를 마치고, 상품 게시와 장바구니 기능에 대해 팀장님이 발표 해주시겠습니다.








